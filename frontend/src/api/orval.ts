/**
 * Generated by orval v7.7.0 🍺
 * Do not edit manually.
 * Blog Scraper
 * Summarize interesting recent AI blog posts
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteGoogleDocDeleteGoogleDocPostParams,
  GDoc,
  GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams,
  HTTPValidationError,
  ListDocumentsListDocumentsGetParams,
  LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams,
  MarkdownFromDocumentsMarkdownFromDocumentsGetParams,
  SourcesSourcesGetParams,
  _HealthStatus,
  _ScrapeStarted,
  _ScrapeStatus
} from './types';

import { customFetch } from './custom-fetch';
/**
 * Get server status
 * @summary Health
 */
export const healthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customFetch<_HealthStatus>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getHealthGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthGet>>> = ({ signal }) => healthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthGet>>>
export type HealthGetQueryError = unknown


export function useHealthGet<TData = Awaited<ReturnType<typeof healthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthGet>>,
          TError,
          Awaited<ReturnType<typeof healthGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthGet<TData = Awaited<ReturnType<typeof healthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthGet>>,
          TError,
          Awaited<ReturnType<typeof healthGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthGet<TData = Awaited<ReturnType<typeof healthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health
 */

export function useHealthGet<TData = Awaited<ReturnType<typeof healthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Starts scraping in an async background task.
 * @summary Start Scrape
 */
export const startScrapeScrapePost = (
    
 signal?: AbortSignal
) => {
      
      
      return customFetch<_ScrapeStarted>(
      {url: `/scrape`, method: 'POST', signal
    },
      );
    }
  


export const getStartScrapeScrapePostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startScrapeScrapePost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startScrapeScrapePost>>, TError,void, TContext> => {
    
const mutationKey = ['startScrapeScrapePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startScrapeScrapePost>>, void> = () => {
          

          return  startScrapeScrapePost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartScrapeScrapePostMutationResult = NonNullable<Awaited<ReturnType<typeof startScrapeScrapePost>>>
    
    export type StartScrapeScrapePostMutationError = unknown

    /**
 * @summary Start Scrape
 */
export const useStartScrapeScrapePost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startScrapeScrapePost>>, TError,void, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof startScrapeScrapePost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStartScrapeScrapePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns the status of a scraping task.
 * @summary Scrape Status
 */
export const scrapeStatusScrapeStatusTaskIdGet = (
    taskId: string,
 signal?: AbortSignal
) => {
      
      
      return customFetch<_ScrapeStatus>(
      {url: `/scrape/status/${taskId}`, method: 'GET', signal
    },
      );
    }
  

export const getScrapeStatusScrapeStatusTaskIdGetQueryKey = (taskId: string,) => {
    return [`/scrape/status/${taskId}`] as const;
    }

    
export const getScrapeStatusScrapeStatusTaskIdGetQueryOptions = <TData = Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError = HTTPValidationError>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScrapeStatusScrapeStatusTaskIdGetQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>> = ({ signal }) => scrapeStatusScrapeStatusTaskIdGet(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ScrapeStatusScrapeStatusTaskIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>>
export type ScrapeStatusScrapeStatusTaskIdGetQueryError = HTTPValidationError


export function useScrapeStatusScrapeStatusTaskIdGet<TData = Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapeStatusScrapeStatusTaskIdGet<TData = Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapeStatusScrapeStatusTaskIdGet<TData = Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Scrape Status
 */

export function useScrapeStatusScrapeStatusTaskIdGet<TData = Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapeStatusScrapeStatusTaskIdGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getScrapeStatusScrapeStatusTaskIdGetQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Fetch a unique list of all sources in the collection.

Parameters:
- roots_only: If True, returns only root sources from `SCRAPERS`.
              Otherwise, fetches distinct sources from the database.

Returns:
- list of unique source names.
 * @summary Sources
 */
export const sourcesSourcesGet = (
    params?: SourcesSourcesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<string[]>(
      {url: `/sources`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSourcesSourcesGetQueryKey = (params?: SourcesSourcesGetParams,) => {
    return [`/sources`, ...(params ? [params]: [])] as const;
    }

    
export const getSourcesSourcesGetQueryOptions = <TData = Awaited<ReturnType<typeof sourcesSourcesGet>>, TError = HTTPValidationError>(params?: SourcesSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSourcesSourcesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sourcesSourcesGet>>> = ({ signal }) => sourcesSourcesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SourcesSourcesGetQueryResult = NonNullable<Awaited<ReturnType<typeof sourcesSourcesGet>>>
export type SourcesSourcesGetQueryError = HTTPValidationError


export function useSourcesSourcesGet<TData = Awaited<ReturnType<typeof sourcesSourcesGet>>, TError = HTTPValidationError>(
 params: undefined |  SourcesSourcesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesSourcesGet>>,
          TError,
          Awaited<ReturnType<typeof sourcesSourcesGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesSourcesGet<TData = Awaited<ReturnType<typeof sourcesSourcesGet>>, TError = HTTPValidationError>(
 params?: SourcesSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesSourcesGet>>,
          TError,
          Awaited<ReturnType<typeof sourcesSourcesGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesSourcesGet<TData = Awaited<ReturnType<typeof sourcesSourcesGet>>, TError = HTTPValidationError>(
 params?: SourcesSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Sources
 */

export function useSourcesSourcesGet<TData = Awaited<ReturnType<typeof sourcesSourcesGet>>, TError = HTTPValidationError>(
 params?: SourcesSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesSourcesGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSourcesSourcesGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Google Docs
 */
export const listGoogleDocsListGoogleDocsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customFetch<GDoc[]>(
      {url: `/list-google-docs`, method: 'GET', signal
    },
      );
    }
  

export const getListGoogleDocsListGoogleDocsGetQueryKey = () => {
    return [`/list-google-docs`] as const;
    }

    
export const getListGoogleDocsListGoogleDocsGetQueryOptions = <TData = Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListGoogleDocsListGoogleDocsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>> = ({ signal }) => listGoogleDocsListGoogleDocsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListGoogleDocsListGoogleDocsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>>
export type ListGoogleDocsListGoogleDocsGetQueryError = unknown


export function useListGoogleDocsListGoogleDocsGet<TData = Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>,
          TError,
          Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListGoogleDocsListGoogleDocsGet<TData = Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>,
          TError,
          Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListGoogleDocsListGoogleDocsGet<TData = Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Google Docs
 */

export function useListGoogleDocsListGoogleDocsGet<TData = Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGoogleDocsListGoogleDocsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListGoogleDocsListGoogleDocsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete Google Doc
 */
export const deleteGoogleDocDeleteGoogleDocPost = (
    params: DeleteGoogleDocDeleteGoogleDocPostParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<boolean>(
      {url: `/delete-google-doc`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getDeleteGoogleDocDeleteGoogleDocPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>, TError,{params: DeleteGoogleDocDeleteGoogleDocPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>, TError,{params: DeleteGoogleDocDeleteGoogleDocPostParams}, TContext> => {
    
const mutationKey = ['deleteGoogleDocDeleteGoogleDocPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>, {params: DeleteGoogleDocDeleteGoogleDocPostParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteGoogleDocDeleteGoogleDocPost(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGoogleDocDeleteGoogleDocPostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>>
    
    export type DeleteGoogleDocDeleteGoogleDocPostMutationError = HTTPValidationError

    /**
 * @summary Delete Google Doc
 */
export const useDeleteGoogleDocDeleteGoogleDocPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>, TError,{params: DeleteGoogleDocDeleteGoogleDocPostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGoogleDocDeleteGoogleDocPost>>,
        TError,
        {params: DeleteGoogleDocDeleteGoogleDocPostParams},
        TContext
      > => {

      const mutationOptions = getDeleteGoogleDocDeleteGoogleDocPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List Documents
 */
export const listDocumentsListDocumentsGet = (
    params: ListDocumentsListDocumentsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<string[]>(
      {url: `/list-documents`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getListDocumentsListDocumentsGetQueryKey = (params: ListDocumentsListDocumentsGetParams,) => {
    return [`/list-documents`, ...(params ? [params]: [])] as const;
    }

    
export const getListDocumentsListDocumentsGetQueryOptions = <TData = Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError = HTTPValidationError>(params: ListDocumentsListDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDocumentsListDocumentsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>> = ({ signal }) => listDocumentsListDocumentsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDocumentsListDocumentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>>
export type ListDocumentsListDocumentsGetQueryError = HTTPValidationError


export function useListDocumentsListDocumentsGet<TData = Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError = HTTPValidationError>(
 params: ListDocumentsListDocumentsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDocumentsListDocumentsGet<TData = Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError = HTTPValidationError>(
 params: ListDocumentsListDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDocumentsListDocumentsGet<TData = Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError = HTTPValidationError>(
 params: ListDocumentsListDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Documents
 */

export function useListDocumentsListDocumentsGet<TData = Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError = HTTPValidationError>(
 params: ListDocumentsListDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDocumentsListDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDocumentsListDocumentsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Llm Prompt From Documents
 */
export const llmPromptFromDocumentsLlmPromptFromDocumentsGet = (
    params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/llm-prompt-from-documents`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getLlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryKey = (params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams,) => {
    return [`/llm-prompt-from-documents`, ...(params ? [params]: [])] as const;
    }

    
export const getLlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryOptions = <TData = Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError = HTTPValidationError>(params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>> = ({ signal }) => llmPromptFromDocumentsLlmPromptFromDocumentsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>>
export type LlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryError = HTTPValidationError


export function useLlmPromptFromDocumentsLlmPromptFromDocumentsGet<TData = Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError = HTTPValidationError>(
 params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLlmPromptFromDocumentsLlmPromptFromDocumentsGet<TData = Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError = HTTPValidationError>(
 params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLlmPromptFromDocumentsLlmPromptFromDocumentsGet<TData = Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError = HTTPValidationError>(
 params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Llm Prompt From Documents
 */

export function useLlmPromptFromDocumentsLlmPromptFromDocumentsGet<TData = Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError = HTTPValidationError>(
 params: LlmPromptFromDocumentsLlmPromptFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof llmPromptFromDocumentsLlmPromptFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLlmPromptFromDocumentsLlmPromptFromDocumentsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Markdown From Documents
 */
export const markdownFromDocumentsMarkdownFromDocumentsGet = (
    params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/markdown-from-documents`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getMarkdownFromDocumentsMarkdownFromDocumentsGetQueryKey = (params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams,) => {
    return [`/markdown-from-documents`, ...(params ? [params]: [])] as const;
    }

    
export const getMarkdownFromDocumentsMarkdownFromDocumentsGetQueryOptions = <TData = Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError = HTTPValidationError>(params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarkdownFromDocumentsMarkdownFromDocumentsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>> = ({ signal }) => markdownFromDocumentsMarkdownFromDocumentsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MarkdownFromDocumentsMarkdownFromDocumentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>>
export type MarkdownFromDocumentsMarkdownFromDocumentsGetQueryError = HTTPValidationError


export function useMarkdownFromDocumentsMarkdownFromDocumentsGet<TData = Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError = HTTPValidationError>(
 params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarkdownFromDocumentsMarkdownFromDocumentsGet<TData = Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError = HTTPValidationError>(
 params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarkdownFromDocumentsMarkdownFromDocumentsGet<TData = Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError = HTTPValidationError>(
 params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Markdown From Documents
 */

export function useMarkdownFromDocumentsMarkdownFromDocumentsGet<TData = Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError = HTTPValidationError>(
 params: MarkdownFromDocumentsMarkdownFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof markdownFromDocumentsMarkdownFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMarkdownFromDocumentsMarkdownFromDocumentsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Google Doc From Documents
 */
export const googleDocFromDocumentsGoogleDocFromDocumentsGet = (
    params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/google-doc-from-documents`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryKey = (params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams,) => {
    return [`/google-doc-from-documents`, ...(params ? [params]: [])] as const;
    }

    
export const getGoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryOptions = <TData = Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError = HTTPValidationError>(params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>> = ({ signal }) => googleDocFromDocumentsGoogleDocFromDocumentsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>>
export type GoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryError = HTTPValidationError


export function useGoogleDocFromDocumentsGoogleDocFromDocumentsGet<TData = Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError = HTTPValidationError>(
 params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGoogleDocFromDocumentsGoogleDocFromDocumentsGet<TData = Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError = HTTPValidationError>(
 params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGoogleDocFromDocumentsGoogleDocFromDocumentsGet<TData = Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError = HTTPValidationError>(
 params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Google Doc From Documents
 */

export function useGoogleDocFromDocumentsGoogleDocFromDocumentsGet<TData = Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError = HTTPValidationError>(
 params: GoogleDocFromDocumentsGoogleDocFromDocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof googleDocFromDocumentsGoogleDocFromDocumentsGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGoogleDocFromDocumentsGoogleDocFromDocumentsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
